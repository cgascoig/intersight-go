// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// ConnectorBaseMessage Connector:Base Message
//
// A base abstract message that handles the common request properties applicable for all the message types.
//
// swagger:model connectorBaseMessage
type ConnectorBaseMessage struct {

	// The secure properties that have large text content as value can be encrypted using AES key. In these cases, the AES key needs to be encrypted using the device connector public key and passed as the value for this property.
	// The secure properties that are encrypted using the AES key are mapped against the property name with prefix 'AES' in SecureProperties dictionary.
	//
	EncryptedAesKey string `json:"EncryptedAesKey,omitempty"`

	// The public key that was used to encrypt the values present in SecureProperties dictionary.
	// If the given public key is not same as device connector's public key, an error reponse with appropriate error message is thrown back.
	//
	EncryptionKey string `json:"EncryptionKey,omitempty"`

	// A dictionary of encrypted secure values mapped against the secure property name. The values that are encrypted using AES key must be mapped against the secure property name with a 'AES' prefix
	// Device connector expects the message body to be a golang template and the template can use the secure property names as placeholders.
	//
	SecureProperties interface{} `json:"SecureProperties,omitempty"`
}

// UnmarshalJSON unmarshals this object from a JSON structure
func (m *ConnectorBaseMessage) UnmarshalJSON(raw []byte) error {
	// AO0
	var dataAO0 struct {
		EncryptedAesKey string `json:"EncryptedAesKey,omitempty"`

		EncryptionKey string `json:"EncryptionKey,omitempty"`

		SecureProperties interface{} `json:"SecureProperties,omitempty"`
	}
	if err := swag.ReadJSON(raw, &dataAO0); err != nil {
		return err
	}

	m.EncryptedAesKey = dataAO0.EncryptedAesKey

	m.EncryptionKey = dataAO0.EncryptionKey

	m.SecureProperties = dataAO0.SecureProperties

	return nil
}

// MarshalJSON marshals this object to a JSON structure
func (m ConnectorBaseMessage) MarshalJSON() ([]byte, error) {
	_parts := make([][]byte, 0, 1)

	var dataAO0 struct {
		EncryptedAesKey string `json:"EncryptedAesKey,omitempty"`

		EncryptionKey string `json:"EncryptionKey,omitempty"`

		SecureProperties interface{} `json:"SecureProperties,omitempty"`
	}

	dataAO0.EncryptedAesKey = m.EncryptedAesKey

	dataAO0.EncryptionKey = m.EncryptionKey

	dataAO0.SecureProperties = m.SecureProperties

	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0)
	if errAO0 != nil {
		return nil, errAO0
	}
	_parts = append(_parts, jsonDataAO0)

	return swag.ConcatJSON(_parts...), nil
}

// Validate validates this connector base message
func (m *ConnectorBaseMessage) Validate(formats strfmt.Registry) error {
	var res []error

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// MarshalBinary interface implementation
func (m *ConnectorBaseMessage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *ConnectorBaseMessage) UnmarshalBinary(b []byte) error {
	var res ConnectorBaseMessage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
